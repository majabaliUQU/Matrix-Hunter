<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ØµÙŠØ§Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #0a0a12;
            color: white;
            font-family: 'Cairo', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        .hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 5;
        }

        #score-display { color: #00ffcc; }
        #lives-display { color: #ff0055; letter-spacing: 5px; }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 18, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            pointer-events: auto;
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }

        .hidden { display: none !important; }

        h1 {
            font-size: 3.5rem;
            margin: 0 0 10px 0;
            background: linear-gradient(to bottom, #00ffcc, #0088aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            filter: drop-shadow(0 0 10px rgba(0, 255, 204, 0.3));
        }

        p { font-size: 1.1rem; color: #aaa; max-width: 80%; line-height: 1.6; margin-bottom: 30px; }

        .btn-primary {
            background: #00ffcc;
            border: none;
            padding: 15px 50px;
            font-size: 1.4rem;
            color: #0a0a12;
            font-weight: 900;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.4);
            transition: all 0.2s;
            font-family: 'Cairo', sans-serif;
            margin-bottom: 15px;
            width: 100%;
            max-width: 300px;
        }

        .btn-primary:active { transform: scale(0.95); background: #fff; }

        .btn-share {
            background: transparent;
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 12px 30px;
            font-size: 1.1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Cairo', sans-serif;
            margin-bottom: 25px;
            width: 100%;
            max-width: 300px;
        }

        .btn-share:hover { background: rgba(0, 255, 204, 0.1); }
        .btn-share:active { transform: scale(0.95); }

        /* Ù…ÙØªØ§Ø­ Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª - ØªÙ… ØªØ¹Ø¯ÙŠÙ„Ù‡ Ù„ÙŠØ¶Ù…Ù† Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„ØµØ­ÙŠØ­ */
        .settings-container {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 50px;
            direction: ltr; /* Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹: Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† Ù„Ø¶Ù…Ø§Ù† ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ø²Ø± */
        }

        .toggle-label {
            color: #fff;
            font-size: 1.2rem;
            font-weight: bold;
            font-family: sans-serif; /* Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ */
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input { opacity: 0; width: 0; height: 0; }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00ffcc;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* ØªÙ†Ø³ÙŠÙ‚ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ù…Ø·ÙˆØ± */
        .dev-box {
            margin-top: auto;
            background: rgba(255, 255, 255, 0.08);
            padding: 10px 20px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            border: 1px solid rgba(0, 255, 204, 0.2);
            margin-bottom: 20px;
        }

        .dev-text {
            color: #ddd;
            font-size: 0.9rem;
            margin: 0;
            font-weight: bold;
        }

        .whatsapp-icon {
            width: 32px;
            height: 32px;
            fill: #25D366;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .whatsapp-icon:hover { transform: scale(1.15); filter: drop-shadow(0 0 5px #25D366); }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">Ø§Ù„Ù†Ù‚Ø§Ø·: Ù </div>
            <div id="lives-display">â¤ï¸â¤ï¸â¤ï¸</div>
        </div>
    </div>

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© -->
    <div id="start-screen" class="overlay">
        <h1>ØµÙŠØ§Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…</h1>
        <p>Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ØªÙ‡Ø¬Ù… Ø¹Ù„ÙŠÙƒ!<br>Ù…Ù‡Ù…ØªÙƒ: Ø±Ø³Ù… "Ù…Ø³ØªØ·ÙŠÙ„" ÙŠØ·Ø§Ø¨Ù‚ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø±Ù‚Ù… Ù„ØªØ¯Ù…ÙŠØ±Ù‡.<br><br>Ù…Ø«Ø§Ù„: Ù„ØªØ¯Ù…ÙŠØ± <strong><span class="demo-num">12</span></strong>ØŒ Ø§Ø±Ø³Ù… <strong><span class="demo-dim">3Ã—4</span></strong> Ø£Ùˆ <strong><span class="demo-dim">2Ã—6</span></strong>.</p>
        
        <button class="btn-primary" onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
        
        <div class="settings-container">
            <span class="toggle-label">123</span>
            <label class="toggle-switch">
                <input type="checkbox" id="num-toggle" onchange="toggleNumerals()">
                <span class="slider"></span>
            </label>
            <span class="toggle-label">Ù¡Ù¢Ù£</span>
        </div>
    </div>

    <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø®Ø³Ø§Ø±Ø© -->
    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color: #ff0055; -webkit-text-fill-color: #ff0055;">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
        <p id="final-score" style="color: white; font-size: 1.5rem; margin-bottom: 20px;">Ø§Ù„Ù†Ù‚Ø§Ø·: Ù </p>
        
        <button class="btn-primary" onclick="resetGame()">Ø§Ù„Ø¹Ø¨ Ù…Ø¬Ø¯Ø¯Ø§Ù‹</button>
        <button class="btn-share" onclick="shareGame()">Ø´Ø§Ø±Ùƒ Ø§Ù„ØªØ­Ø¯ÙŠ Ù…Ø¹ Ø£ØµØ¯Ù‚Ø§Ø¦Ùƒ</button>

        <!-- ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ù…Ø·ÙˆØ± -->
        <div class="dev-box">
            <p class="dev-text">ØªØ·ÙˆÙŠØ± Ù…Ø­Ù…Ø¯ Ø¬Ø¨Ù„ÙŠ</p>
            <a href="https://wa.me/966505501575" target="_blank" aria-label="ØªÙˆØ§ØµÙ„ Ø¹Ø¨Ø± ÙˆØ§ØªØ³Ø§Ø¨">
                <svg class="whatsapp-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                    <!-- Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. -->
                    <path d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7 .9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"/>
                </svg>
            </a>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
let useArabicNumerals = false; // false = 123 (Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: ÙŠØ³Ø§Ø±), true = Ù¡Ù¢Ù£ (ÙŠÙ…ÙŠÙ†)

// Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
let gameState = 'START'; 
let score = 0;
let lives = 3;
let frameCount = 0;
let difficultyLevel = 1;

// Ø§Ù„Ø´Ø¨ÙƒØ©
const GRID_COLS = 10;
const GRID_ROWS = 10;
let cellSize = 0;
let gridStartX = 0;
let gridStartY = 0;

// Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
let isDragging = false;
let startCell = { col: -1, row: -1 };
let currentCell = { col: -1, row: -1 };
let selectedRect = null; 
let dragPosition = { x: 0, y: 0 };

// ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
let enemies = [];
let particles = [];
let lasers = [];

// Ø§Ù„ØµÙˆØª
let audioCtx = null;

// ==========================================
// Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ©
// ==========================================
function shareGame() {
    const currentScore = formatNum(score);
    const text = `ØªØ­Ø¯ÙŠ Ø§Ù„Ø°ÙƒØ§Ø¡ ÙˆØ§Ù„Ø³Ø±Ø¹Ø©! ğŸš€\nÙ„Ù‚Ø¯ Ø­Ù‚Ù‚Øª ${currentScore} Ù†Ù‚Ø·Ø© ÙÙŠ Ù„Ø¹Ø¨Ø© *ØµÙŠØ§Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…*... Ù‡Ù„ ØªÙ…ØªÙ„Ùƒ Ø§Ù„Ù…Ù‡Ø§Ø±Ø© Ù„Ù‡Ø²ÙŠÙ…ØªÙŠØŸ ğŸ”¥\nØ¬Ø±Ø¨ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¢Ù† ÙˆØ£Ø±Ù†ÙŠ Ù…Ø§ Ù„Ø¯ÙŠÙƒ! ğŸ’ª\n`;
    const url = window.location.href; // Ø±Ø§Ø¨Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©

    if (navigator.share) {
        navigator.share({
            title: 'Ù„Ø¹Ø¨Ø© ØµÙŠØ§Ø¯ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…',
            text: text,
            url: url
        }).catch(err => {
            console.log('Error sharing:', err);
        });
    } else {
        // Ø¨Ø¯ÙŠÙ„ ÙÙŠ Ø­Ø§Ù„ Ø¹Ø¯Ù… Ø¯Ø¹Ù… Ø§Ù„Ù…ØªØµÙØ­ Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©
        // Ù†Ù‚ÙˆÙ… Ø¨Ù†Ø³Ø® Ø§Ù„Ù†Øµ Ù„Ù„Ø­Ø§ÙØ¸Ø©
        const dummy = document.createElement("textarea");
        document.body.appendChild(dummy);
        dummy.value = text + " " + url;
        dummy.select();
        document.execCommand("copy");
        document.body.removeChild(dummy);
        alert("ØªÙ… Ù†Ø³Ø® Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠ! Ø´Ø§Ø±ÙƒÙ‡Ø§ Ù…Ø¹ Ø£ØµØ¯Ù‚Ø§Ø¦Ùƒ Ø§Ù„Ø¢Ù†.");
    }
}

// ==========================================
// Ø¯Ø§Ù„Ø© ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù…
// ==========================================
function formatNum(n) {
    if (!useArabicNumerals) return n;
    return n.toString().replace(/\d/g, d => "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©"[d]);
}

function toggleNumerals() {
    const checkbox = document.getElementById('num-toggle');
    // Ø§Ù„Ø²Ø± Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± (ØºÙŠØ± Ù…ÙØ¹Ù„) = 123
    // Ø§Ù„Ø²Ø± Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ† (Ù…ÙØ¹Ù„) = Ù¡Ù¢Ù£
    useArabicNumerals = checkbox.checked;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø«Ø§Ù„ ÙÙŠ Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    const demoNum = document.querySelector('.demo-num');
    const demoDim = document.querySelectorAll('.demo-dim');
    
    demoNum.innerText = formatNum(12);
    demoDim[0].innerText = formatNum(3) + "Ã—" + formatNum(4);
    demoDim[1].innerText = formatNum(2) + "Ã—" + formatNum(6);
}

// Ø¶Ø¨Ø· Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£ÙˆÙ„ÙŠ
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const margin = 20;
    const availableWidth = Math.min(canvas.width - (margin * 2), 600);
    cellSize = Math.floor(availableWidth / GRID_COLS);

    gridStartX = (canvas.width - (cellSize * GRID_COLS)) / 2;
    gridStartY = canvas.height - (cellSize * GRID_ROWS) - 80; 
}

window.addEventListener('resize', resize);
resize();

// ==========================================
// Ù…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
// ==========================================

function getFactorsForLevel(level) {
    if (level === 1) return [1, 2, 5, 10]; 
    if (level === 2) return [1, 2, 3, 4, 5, 10];
    if (level === 3) return [1, 2, 3, 4, 5, 6, 9, 10];
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
}

function spawnEnemy() {
    const factors = getFactorsForLevel(difficultyLevel);
    const f1 = factors[Math.floor(Math.random() * factors.length)];
    const f2 = Math.floor(Math.random() * 10) + 1;
    const value = f1 * f2;
    
    // Ø§Ù„Ø³Ø±Ø¹Ø©
    const speed = 0.15 + (score / 3000);

    enemies.push({
        x: Math.random() * (canvas.width - 60) + 30,
        y: -60,
        value: value,
        radius: 28,
        speed: speed,
        color: `hsl(${Math.random() * 360}, 70%, 60%)`
    });
}

// ==========================================
// Ø§Ù„ØµÙˆØª
// ==========================================
function playSound(type) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;

    if (type === 'pop') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gainNode.gain.setValueAtTime(0.05, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start();
        osc.stop(now + 0.1);
    } else if (type === 'hit') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start();
        osc.stop(now + 0.3);
    } else if (type === 'error') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start();
        osc.stop(now + 0.3);
    }
}

// ==========================================
// Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
// ==========================================

function getGridPos(clientX, clientY) {
    const x = clientX - gridStartX;
    const y = clientY - gridStartY;
    const col = Math.floor(x / cellSize);
    const row = Math.floor(y / cellSize);
    
    const clampedCol = Math.max(0, Math.min(GRID_COLS - 1, col));
    const clampedRow = Math.max(0, Math.min(GRID_ROWS - 1, row));

    if (x > -50 && x < (GRID_COLS * cellSize) + 50 && 
        y > -50 && y < (GRID_ROWS * cellSize) + 50) {
        return { col: clampedCol, row: clampedRow };
    }
    return null;
}

function handleInputStart(e) {
    if (gameState !== 'PLAYING') return;
    
    const touch = e.touches ? e.touches[0] : e;
    const pos = getGridPos(touch.clientX, touch.clientY);
    
    if (pos) {
        e.preventDefault();
        isDragging = true;
        startCell = pos;
        currentCell = pos;
        dragPosition = { x: touch.clientX, y: touch.clientY };
        updateSelection();
        playSound('pop');
    }
}

function handleInputMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const touch = e.touches ? e.touches[0] : e;
    dragPosition = { x: touch.clientX, y: touch.clientY };
    const pos = getGridPos(touch.clientX, touch.clientY);
    
    if (pos) {
        if (pos.col !== currentCell.col || pos.row !== currentCell.row) {
            currentCell = pos;
            playSound('pop');
        }
        updateSelection();
    }
}

function handleInputEnd(e) {
    if (!isDragging) return;
    e.preventDefault();
    isDragging = false;
    fireWeapon();
    selectedRect = null;
}

function updateSelection() {
    const c1 = Math.min(startCell.col, currentCell.col);
    const c2 = Math.max(startCell.col, currentCell.col);
    const r1 = Math.min(startCell.row, currentCell.row);
    const r2 = Math.max(startCell.row, currentCell.row);
    
    const w = (c2 - c1) + 1;
    const h = (r2 - r1) + 1;
    const area = w * h;
    
    selectedRect = { c: c1, r: r1, w: w, h: h, area: area };
}

function fireWeapon() {
    if (!selectedRect) return;
    
    const damage = selectedRect.area;
    let hitSomething = false;

    const rectCenterX = gridStartX + (selectedRect.c * cellSize) + (selectedRect.w * cellSize / 2);
    const rectCenterY = gridStartY + (selectedRect.r * cellSize) + (selectedRect.h * cellSize / 2);

    for (let i = enemies.length - 1; i >= 0; i--) {
        if (enemies[i].value === damage) {
            createExplosion(enemies[i].x, enemies[i].y, enemies[i].color);
            lasers.push({
                x1: rectCenterX, y1: rectCenterY, 
                x2: enemies[i].x, y2: enemies[i].y, 
                life: 15, color: '#00ffcc', hit: true
            });
            enemies.splice(i, 1);
            score += 10;
            hitSomething = true;
            playSound('hit');
        }
    }

    if (!hitSomething) {
        lasers.push({
            x1: rectCenterX, y1: rectCenterY, 
            x2: rectCenterX, y2: -50, 
            life: 8, color: '#ff0055', hit: false
        });
        playSound('error');
    }
    
    if (score > 100) difficultyLevel = 2;
    if (score > 300) difficultyLevel = 3;
    if (score > 600) difficultyLevel = 4;
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 20; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 12,
            vy: (Math.random() - 0.5) * 12,
            life: 40,
            color: color
        });
    }
}

// ==========================================
// Ø§Ù„Ø±Ø³Ù…
// ==========================================

function drawGrid() {
    ctx.lineWidth = 1;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.fillRect(gridStartX, gridStartY, GRID_COLS * cellSize, GRID_ROWS * cellSize);

    ctx.strokeStyle = '#333';
    for (let c = 0; c <= GRID_COLS; c++) {
        const x = gridStartX + c * cellSize;
        ctx.beginPath(); ctx.moveTo(x, gridStartY); ctx.lineTo(x, gridStartY + GRID_ROWS * cellSize); ctx.stroke();
    }
    for (let r = 0; r <= GRID_ROWS; r++) {
        const y = gridStartY + r * cellSize;
        ctx.beginPath(); ctx.moveTo(gridStartX, y); ctx.lineTo(gridStartX + GRID_COLS * cellSize, y); ctx.stroke();
    }

    if (selectedRect) {
        const x = gridStartX + selectedRect.c * cellSize;
        const y = gridStartY + selectedRect.r * cellSize;
        const w = selectedRect.w * cellSize;
        const h = selectedRect.h * cellSize;

        ctx.fillStyle = 'rgba(0, 255, 204, 0.2)';
        ctx.fillRect(x, y, w, h);
        
        ctx.strokeStyle = '#00ffcc';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);

        // Ø§Ù„Ø±Ø³Ù… ÙÙˆÙ‚ Ø§Ù„Ø¥ØµØ¨Ø¹
        let labelX = dragPosition.x;
        let labelY = dragPosition.y - 80;

        if (labelX < 50) labelX = 50;
        if (labelX > canvas.width - 50) labelX = canvas.width - 50;
        if (labelY < 50) labelY = 50;

        // Ù†Øµ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù…Ø¹ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const text = `${formatNum(selectedRect.w)} Ã— ${formatNum(selectedRect.h)}`;
        
        ctx.font = '900 30px "Cairo", sans-serif';
        const textMetrics = ctx.measureText(text);
        const textW = textMetrics.width;
        
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.beginPath();
        ctx.roundRect(labelX - textW/2 - 15, labelY - 25, textW + 30, 50, 10);
        ctx.fill();
        ctx.strokeStyle = '#00ffcc';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, labelX, labelY + 4);
    }
}

function update() {
    if (gameState !== 'PLAYING') return;

    ctx.fillStyle = '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(0, 255, 204, 0.03)';
    if (frameCount % 10 === 0) {
        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 2, 20);
    }

    if (frameCount % 280 === 0) spawnEnemy(); 
    frameCount++;

    ctx.font = 'bold 26px "Cairo", sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.y += e.speed;

        const gradient = ctx.createRadialGradient(e.x, e.y, 5, e.x, e.y, e.radius + 5);
        gradient.addColorStop(0, e.color);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath(); ctx.arc(e.x, e.y, e.radius + 10, 0, Math.PI * 2); ctx.fill();

        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#111';
        ctx.fill();
        ctx.strokeStyle = e.color;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        // ØªØ·Ø¨ÙŠÙ‚ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
        ctx.fillText(formatNum(e.value), e.x, e.y + 4);

        if (e.y > gridStartY - e.radius) {
            enemies.splice(i, 1);
            lives--;
            playSound('error');
            createExplosion(e.x, e.y, '#ff0055');
            if (lives <= 0) endGame();
        }
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        ctx.globalAlpha = p.life / 40;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
        if (p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;

    for (let i = lasers.length - 1; i >= 0; i--) {
        let l = lasers[i];
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.strokeStyle = l.color;
        ctx.lineWidth = l.hit ? l.life / 2 : 1;
        ctx.stroke();
        l.life--;
        if (l.life <= 0) lasers.splice(i, 1);
    }

    drawGrid();
    updateUI();

    requestAnimationFrame(update);
}

function updateUI() {
    document.getElementById('score-display').innerText = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${formatNum(score)}`;
    document.getElementById('lives-display').innerText = 'â¤ï¸'.repeat(lives);
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();

    gameState = 'PLAYING';
    score = 0;
    lives = 3;
    enemies = [];
    particles = [];
    lasers = [];
    difficultyLevel = 1;
    frameCount = 0;
    update();
}

function endGame() {
    gameState = 'GAMEOVER';
    document.getElementById('final-score').innerText = `Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©: ${formatNum(score)}`;
    document.getElementById('game-over-screen').classList.remove('hidden');
}

function resetGame() {
    startGame();
}

canvas.addEventListener('mousedown', handleInputStart);
window.addEventListener('mousemove', handleInputMove);
window.addEventListener('mouseup', handleInputEnd);

canvas.addEventListener('touchstart', handleInputStart, { passive: false });
canvas.addEventListener('touchmove', handleInputMove, { passive: false });
canvas.addEventListener('touchend', handleInputEnd, { passive: false });

// ØªØ´ØºÙŠÙ„ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© Ù„Ø¶Ø¨Ø· Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
toggleNumerals();

</script>
</body>
</html>




